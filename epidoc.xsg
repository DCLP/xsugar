NL = [\r\n]+
SP = [ ]
SPO = [ ]+ (MAX)
SPO2 = [ ]*
ABBR = "(  )"+

BEGOPT = "<:"
ENDOPT = ":>"
BEGNUM = "<#"
ENDNUM = "#>"
BEGSEG = "<\&"
ENDSEG = "\&>"
BEGEXP = "<+"
ENDEXP = "+>"
BEGAB = "<="
ENDAB = "=>"
BEGMIABBR = "<@"
ENDMIABBR = "@>"

FRACSYM = [êÖµêÖ∑êÖ∏]+

UNDERDOT = "\u0323"
//ca. with 0 or more spaces followed by ? mark
CAUNKNOWN = "ca."[ ]*"\?"
LEADCA = "ca."[ ]*
//																								   ¬®ŒÑ·øØ·øæ·æø¬¥\^·øæ·æø
// WORD breaks at space and does not allow DOT
WORD = ([^ \/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

// WORDVEST breaks at space and does not allow DOT  - added 'v' to keep vestig out
WORDVEST = ([^ \/\\\n\r\t\[\]\^<>v_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDA does not allow underdot (\u0323 at the end) - used to make abbr work - A = abbreviation
WORDA = ([^ \/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDAVEST does not allow underdot (\u0323 at the end) - used to make abbr work - A = abbreviation - added 'v' to keep vestig out
WORDAVEST = ([^ \/\\\n\r\t\[\]\^<>v_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDS allows space (therefore multiple words) and DOT
WORDS = ([^\/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDSNONUM allows space (therefore multiple words) and DOT - not numbers 0-9
WORDSNONUM = ([^\/\\\n\r\t\[\]\^<>0-9_#@~„Äö„Äõ$\*\&\,\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDSF allows space (therefore multiple words) and DOT - allow ?, \, , $, +, : for foreign language
WORDSF = ([^\/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ\*\&\=\|\'\!\(\)\{\}\"¬Ø‚â°\u0323]+) (MAX)

//WORDSBL allows left and right paren and '+' sign - used to make app lem editorial work when lem resp= includes parens (ex. (BL 1.24))
WORDSBL = ([^\/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\:\=\|\'\!\{\}\?\"¬Ø‚â°\u0323]+) (MAX)

//WORDSLR allows comma - used to make app lem BL work when lem resp= includes comma (ex. lem resp='cf. 5.11, 3.10')
WORDSLR = ([^\/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

// wordsnum allow '/' for fractional numbers - added DOT to break .gap on 7/7 see if break other things
WORDSNUM = ([^\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

//WORDSSIC allows space (therefore multiple words) and does not allow DOT to break correctly for .gap - added vestig 7/7 for suprelinear
WORDSSIC = ([^\/\\\n\r\t\[\]\^<>vestig_#@~„Äö„Äõ$\*\&\,\.\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+) (MAX)

// WORDOPT breaks at space but has * as reg exp attribute so allows for no word to exist also in that position
WORDOPT = ([^ \/\\\n\r\t\[\]\^<>_#@~„Äö„Äõ$\*\&\,\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]*) (MAX)

NUM = [0-9]+
LINENUM = [0-9]+[/\,a-zA-Z]*[ms0-9]*
GAPEXTNUM = [c]?[.]?[0-9]+
ANYLETTER = [^\/\\\t\[\]\^<>_#@~„Äö„Äõ$\*\&\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]
//added 0-9 to eliminate numbers 7/22 to fix reversability on some sup lost
ANYMULT = [^\/\\\t\[\]\^<>0-9_#@~„Äö„Äõ$\*\&\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]+

//the third part of HANDSHIFT reg exp is same as ANYLETTER except does not allow space
HANDSHIFT = m{1}[0-9]+[^ \/\\\t\[\]\^<>_#@~„Äö„Äõ$\*\&\:\=\|\'\!\(\)\{\}\?\"¬Ø‚â°+\u0323]?

DOT = "."
QUESTION = [\?]?

// symbolnum is for recognizing either a fraction or whole number with multiple digits
SYMBOLNUM = [0-9]+\/{1}[0-9]+|[0-9]+

// symnummulti is for recognizing multiple fractions or whole numbers with multiple digits divided by 1 or more spaces
SYMNUMMULTI = ([ ]*[0-9]+\/{1}[0-9]+[ ]+|[ ]*[0-9]+[ ]+)+

// appnum is for recognizing app_lem number
APPNUM = [0-9]+\.{1}[0-9]+

LANGLIST = ((Demotic)|(Coptic)|(Arabic)|(Nabatean)|(Aramaic))

// actual grammar starts below at file.  regular expression used are above

// had to wrap multiple ab sections in root tag to keep from getting XML not well formed error - decided to do whether multiple or not
file : [abtag a] = <wrapab>[abtag a]</>
     : =
	 
// 1st line for 1 ab section, 2nd line for multiple ab sections, 3rd line for multiple ab sections with new line break, 4th line for empty tag ab section
abtag : [BEGAB] [items z] [ENDAB] = <ab>[items z]</>
		>: [BEGAB] [items z] [ENDAB] [abtag more] = <ab>[items z]</> [abtag more]
		>: [BEGAB] [items z] [ENDAB] [NL] [abtag more] = <ab>[items z]</> [NL] [abtag more]
		>: [BEGAB] [ENDAB] = <ab></>

items : [item i] [items more] = [item i] [items more]  
		>: [item p] = [item p]	

linenumber : [LINENUM n] "." " " = <lb n=[LINENUM n]/>
				 >: [LINENUM n] "." "div " = <lb n=[LINENUM n] type="worddiv"/>

newline : [NL n] = [NL n]

unclears_SP_non_terminal : [SP] [UNDERDOT] [unclears_SP_non_terminal mu] = "\u00A0" [unclears_SP_non_terminal mu]
								 >: [SP] [UNDERDOT] = "\u00A0"

unclears_non_terminal : [ANYLETTER a] [UNDERDOT] [unclears_non_terminal mu] = [ANYLETTER a] [unclears_non_terminal mu]
								 >: [ANYLETTER a] [UNDERDOT] = [ANYLETTER a]
		 
morenum : [BEGNUM] [WORD w] "=" [SYMBOLNUM x] [ENDNUM] [morenum y] = <num value=[SYMBOLNUM x]>[WORD w]</>  [morenum y]
			   >: [BEGNUM] [WORD w] "=" [SYMBOLNUM x] [ENDNUM] = <num value=[SYMBOLNUM x]>[WORD w]</>
		 
expand 	: [WORD a] "(" [WORD b] ")" [expand more] = [WORD a]<ex>[WORD b]</>[expand more]
			>: [WORD a] "(" [WORD b] ")" = [WORD a]<ex>[WORD b]</>
			
expandex : "(" [WORDS b] ")" [expandex more] = <ex>[WORDS b]</>[expandex more]
			>: "(" [WORDS b] ")" = <ex>[WORDS b]</>
			
expando : [items a] "(" [WORD b] ")" [expando more] = [items a]<ex>[WORD b]</>[expando more]
			>: [items a] "(" [WORD b] ")" = [items a]<ex>[WORD b]</>
			>: [items a] "(" [items c] ")" = [items a]<ex>[items c]</>

expandim : [items a] "(" [WORD b] ")" = [items a]<ex>[WORD b]</>
expandii : [items a] "(" [items c] ")" = [items a]<ex>[items c]</>

item 
	: [linenumber l] = [linenumber l]
	: [newline n] = [newline n]
	
	//---special_lines---
	//(23, perp)
	: "(" [LINENUM v] ", " [WORD w] ")" = <lb n=[LINENUM v] rend=[WORD w]/>

	//---test_abbreviation_unknown_resolution---
	// ab( )
	: " " [WORDA w] [ABBR] = <abbr>[WORDA w]</>
	>: [BEGMIABBR] [items w] [ABBR] [ENDMIABBR] = <abbr>[items w]</>

//---test_uncertain_diacritical_diaeresis---
	// (¬®)
	: " " [ANYLETTER a] "(¬®)" = <hi rend="diaeresis">[ANYLETTER a]</>
	>: " " [ANYLETTER a] [UNDERDOT] "(¬®)" = <hi rend="diaeresis"><unclear>[ANYLETTER a]</></>
	
	//---test_uncertain_diacritical_grave---
	// (·øØ) u+1fef
	: " " [ANYLETTER a] "(·øØ)" = <hi rend="grave">[ANYLETTER a]</>	
	
	//---test_uncertain_diacritical_oxia---
	// (ŒÑ)
	: " " [ANYLETTER a] "(ŒÑ)" = <hi rend="oxia">[ANYLETTER a]</>
//10	
	//---test_uncertain_diacritical_spiritus_asper--- can also be known as greek dasia when combined with space per wikipeidia
	// (·øæ)
	: " " [ANYLETTER a] "( ·øæ)" = <hi rend="asper">[ANYLETTER a]</>
	
	//---test_uncertain_diacritical_acute---
	// (¬¥)
	: " " [ANYLETTER a] "(¬¥)" = <hi rend="acute">[ANYLETTER a]</>
	
	//---test_uncertain_diacritical_circumflex---
	// (^)
	: " " [ANYLETTER a] "(^)" = <hi rend="circumflex">[ANYLETTER a]</>
	>: " " [ANYLETTER a] [UNDERDOT] "(^)" = <hi rend="circumflex"><unclear>[ANYLETTER a]</></>
	
	//---test_uncertain_diacritical_spiritus_lenis--- can also be known as greek psili when combined with space per wikipeidia
	// (·æø)
	: " " [ANYLETTER a] "( ·æø)" = <hi rend="lenis">[ANYLETTER a]</>
	>: " " [ANYLETTER a] [UNDERDOT] "( ·æø)" = <hi rend="lenis"><unclear>[ANYLETTER a]</></>

//wrote for specific reversability case in psi.6.703 7 /21 - will see if it fixes anything else                <expan>·º®œÉ<unclear>Œ±</unclear><hi rend='diaeresis'><unclear>Œê</unclear></hi><unclear>Œø</unclear><ex>œÖ</ex></expan>
	: [BEGEXP] [ANYMULT b] [ANYLETTER e] [UNDERDOT] [ANYLETTER c] [UNDERDOT] "(¬®)" [ANYLETTER a] [UNDERDOT]  "(" [ANYLETTER d] ")" [ENDEXP] = <expan>[ANYMULT b]<unclear>[ANYLETTER e]</><hi rend="diaeresis"><unclear>[ANYLETTER c]</></><unclear>[ANYLETTER a]</><ex>[ANYLETTER d]</></>

//wrote for specific reversability case in p.cair.masp.3.67325 - will see if it fixes anything else
	: [BEGEXP] [WORD d] " " [ANYLETTER c] "(¬®)" [WORD a] "(" [WORD b] ")" [ENDEXP] = <expan>[WORD d]<hi rend="diaeresis">[ANYLETTER c]</>[WORD a]<ex>[WORD b]</></>
//wrote for specific reversability case in p.ross.georg.3.49 - will see if it fixes anything else
	: [BEGEXP] [ANYLETTER c] "(¬®)" [WORD a] "(" [WORD b] ")" [WORD d] "(" [WORD e] ")" [ENDEXP] = <expan><hi rend="diaeresis">[ANYLETTER c]</>[WORD a]<ex>[WORD b]</>[WORD d]<ex>[WORD e]</></>
//wrote for specific reversability case in p.ross.georg.3.38 7 /20 - will see if it fixes anything else         
	: [BEGEXP] [ANYLETTER c] "(¬®)" [WORD a] "[" [WORD b] "(" [WORD d] ")" "]" [ENDEXP] = <expan><hi rend="diaeresis">[ANYLETTER c]</>[WORD a]<supplied reason="lost">[WORD b]<ex>[WORD d]</></></>
//the line below causes horizontal ambiguity but does not break anything that I can tell for our purposes - will push up and see - makes run long
//re-wrote to look for specific case in bgu.1 - makes run normal again - will push up and see how much breaks - also moved lower in group here
// removed [UNDERDOT] after ANYLETTER on 7/21 - not sure why it was there - making test case not work right and moved up here
	: [BEGEXP] [ANYLETTER c] "(¬®)" [WORD a] "(" [WORD b] ")" [ENDEXP] = <expan><hi rend="diaeresis">[ANYLETTER c]</> [WORD a]<ex>[WORD b]</></>
//wrote for specific reversability case in p.ness.3.55 7 /21 - will see if it fixes anything else 
	: [BEGEXP] [ANYLETTER c] [UNDERDOT] "(¬®)" [items a] "(" [WORD d] ")" [ENDEXP] = <expan><hi rend="diaeresis"><unclear>[ANYLETTER c]</></>[items a]<ex>[WORD d]</></>

	: [BEGEXP] "(" [WORDSNUM a] ")" [ENDEXP] = <expan><ex>[WORDSNUM a]</></>
	>: [BEGEXP] "(" [items a] ")" [ENDEXP] = <expan><ex>[items a]</></>

	>: [BEGEXP] [expand e] [ENDEXP] = <expan>[expand e]</>
	>: [BEGEXP] [expand e] [WORD a] [ENDEXP] = <expan>[expand e] [WORD a]</>
//20
	>: [linenumber l] [BEGEXP] [expando e] [ENDEXP] = [linenumber l] <expan>[expando e]</>
//	>: [expando e] = <expan>[expando e]</>
	>: [BEGEXP] [expando e] [WORD a] [ENDEXP] = <expan>[expando e] [WORD a]</>
	>: [SPO s] [BEGEXP] [expando e] [ENDEXP] = [SPO s] <expan>[expando e]</>
	>: [BEGEXP] [expandim e] [ENDEXP] = <expan>[expandim e]</>
	>: [BEGEXP] [expandii e] [ENDEXP]= <expan>[expandii e]</>

//	>: [BEGEXP] [items i] [WORD a] "(" [WORD b] ")" [ENDEXP] = <expan>[items i] [WORD a]<ex>[WORD b]</></>
	
	//---test unclear characters = underdots
	: [FRACSYM f] [UNDERDOT] = <unclear>[FRACSYM f]</>
	>: [unclears_non_terminal u] = <unclear>[unclears_non_terminal u]</>
//below line breaks xml reversability in p.vind.worp/p.vind.worp.11.xml - had here to fix something, not sure what now
//added the lne 6/22 12 noon - commented out 7/9 to see how much fixes vs. how much it breaks
//	>: [unclears_non_terminal u] "*" [WORDS k] "*" [unclears_non_terminal w] = <unclear>[unclears_non_terminal u] <g type=[WORDS k]></> [unclears_non_terminal w]</>
	>: "*" [UNDERDOT] [WORDS k]  [UNDERDOT] "*" = <unclear><g type=[WORDS k]></></>
	
	//---choice---
	//  <:a|orth|b|:> 
	: [BEGOPT] [WORDAVEST a] "?" "|orth|" [WORDAVEST b] [ENDOPT] = <choice><corr cert="low">[WORDAVEST a]</><sic>[WORDAVEST b]</></>
// the line below causes horizontal ambiguity but does what it needs to - set up for case such as   p.cair.zen/p.cair.zen.3/p.cair.zen.3.59403.xml
// will see if it handles it tomorrow and what else it does
	>: [BEGOPT] [WORDAVEST a] "?" [items c] "|orth|" [items d] [ENDOPT] = <choice><corr cert="low">[WORDAVEST a][items c]</><sic>[items d]</></>
	>: [BEGOPT] [WORDAVEST a] "?" "|orth|" [items d] "?" [ENDOPT] = <choice><corr cert="low">[WORDAVEST a]</><sic cert="low">[items d]</></>
	>: [BEGOPT] [WORDAVEST a] "|orth|" [items d] "?" [ENDOPT] = <choice><corr>[WORDAVEST a]</><sic cert="low">[items d]</></>
	>: [BEGOPT] [items a] "?" "|orth|" [items d] "?" [ENDOPT] = <choice><corr cert="low">[items a]</><sic cert="low">[items d]</></>
	>: [BEGOPT] [items a] "|orth|" [items d] "?" [ENDOPT] = <choice><corr>[items a]</><sic cert="low">[items d]</></>
//30
	: [BEGOPT] [WORDAVEST a] "|orth|" [WORDAVEST b] [ENDOPT] = <choice><corr>[WORDAVEST a]</><sic>[WORDAVEST b]</></>
	>: [BEGOPT] [items a] "|orth|" [WORDAVEST b] [ENDOPT] = <choice><corr>[items a]</><sic>[WORDAVEST b]</></>
	>: [BEGOPT] [WORDAVEST a] "|orth|" [items b] [ENDOPT] = <choice><corr>[WORDAVEST a]</><sic>[items b]</></>
	>: [BEGOPT] [items a] "|orth|" [items b] [ENDOPT] = <choice><corr>[items a]</><sic>[items b]</></>
	>: [BEGOPT] "|orth|" [WORDAVEST b] [ENDOPT] = <choice><corr></><sic>[WORDAVEST b]</></>
	>: [BEGOPT] "|orth|" [items b] [ENDOPT] = <choice><corr></><sic>[items b]</></>

	//---milestone---
	//  '----' or  '--------'
	: "--------" = <milestone rend="horizontal-rule" unit="undefined"></>
	: "----" = <milestone rend="paragraphos" unit="undefined"></>
	: "###" = <milestone rend="box"></>
	
	//---test_illegible_dot_gap---
	// .1, .2, .3
	: [DOT] [GAPEXTNUM n] = <gap extent=[GAPEXTNUM n] reason="illegible" unit="character"></>  
//40
	//---test_illegible_dot_max---
	// .#{n}-#{n}
	: [DOT] [NUM v] "-" [NUM w] = <gap extent=[NUM v] extentmax=[NUM w] reason="illegible" unit="character"></>
	
	//---test_illegible_dot_lin---
	// .1lin, .2lin, .3lin
	: [DOT] [GAPEXTNUM n] "lin" = <gap extent=[GAPEXTNUM n] reason="illegible" unit="line"></>  
	
	//---test_illegible_dot_lin_extentmax---
	// .1-2lin
	: [DOT] [NUM n] "-" [NUM w] "lin" = <gap extent=[NUM n] extentmax=[NUM w] reason="illegible" unit="line"></>  
	
	//---test_illegible_gap_ca---
	// ca.1, ca.2, ca.3
	: [LEADCA] [GAPEXTNUM j] = <gap reason="illegible" extent=[GAPEXTNUM j] unit="character" precision="circa"></>
	
	//---test_lang_gap---
	//(Lang: Demotic 2 lines)
	: "(Lang: " [LANGLIST l] " " [GAPEXTNUM v] " lines)" = <gap desc=[LANGLIST l] extent=[GAPEXTNUM v] reason="ellipsis" unit="line"></>
	
	//---test_lines_not_transcribed---
	//"lines not transcribed"
	: "(Lines: " [GAPEXTNUM v] " not transcribed)" = <gap extent=[GAPEXTNUM v] reason="ellipsis" unit="line"></>
	
	//---subscript---
	//   /abc\
	: "\/" [WORD a] "\\" = <hi rend="subscript">[WORD a]</>
	>: "\/" [items i] "\\" = <hi rend="subscript">[items i]</>
	
	//---tall---
	//   ^abc^
	: "\^" [WORD a] "\^" = <hi rend="tall">[WORD a]</>
	>: "\^" [items i] "\^" = <hi rend="tall">[items i]</>
//50
	//---superscript---
	//   \|abc|/
    : "\\\|" [WORD a] "\|\/" = <hi rend="superscript">[WORD a]</>
	>: "\\\|" [items i] "\|\/" = <hi rend="superscript">[items i]</>
	
	//---add_place_supralinear---
	//   \abc/
    : "#\\" [WORDSSIC a] "\/#" = <add place="supralinear">[WORDSSIC a]</>
	: "#\\" [WORDSSIC a] "?" "\/#" = <add cert="low" place="supralinear">[WORDSSIC a]</>
	>: "#\\" [items a] "\/#" = <add place="supralinear">[items a]</>
	>: "#\\" [items a] "?" "\/#" = <add cert="low" place="supralinear">[items a]</>
	
	//---add_place_infralinear---
	//   \abc/
    : "<\/" [WORDS a] "\\>" = <add place="infralinear">[WORDS a]</>
	>: "<\/" [items a] "\\>" = <add place="infralinear">[items a]</>
	
	//---add_place_intralinear---
	//   \abc/
    : "<\\" [WORDS a] "\/>" = <add place="intralinear">[WORDS a]</>
	>: "<\\" [items a] "\/>" = <add place="intralinear">[items a]</>
//60
		//---add_place_marginal---
	//   \abc/
    : "<|" [WORD a] "|>" = <add place="marginal" rend="sling">[WORD a]</>
	>: "<|" [items a] "|>" = <add place="marginal" rend="sling">[items a]</>
	
	//---grave---
	//   \abc/
//    : "\|*" [WORD a] "*\|" = <hi rend="grave">[WORD a]</>
	
	//---supraline---
	//   ¬Øabc¬Ø - uses non-combining macron
	: "¬Ø" [WORDVEST a] "¬Ø" = <hi rend="supraline">[WORDVEST a]</>
	>: "¬Ø" [items i] "¬Ø" = <hi rend="supraline">[items i]</>
		
	//---supraline_underline---
	//   |_abc_|
    : "‚â°" [WORD a] "‚â°" = <hi rend="supraline-underline">[WORD a]</>
		
	//---undefined_parallel---
	//  _abc_  - underlines
	// added @ 7/16 to make difference between beginning and ending symbol or xsugar would not parse Leiden+ correctly
	// 7/20 changed illegible to undefined per gabby change to data
    : "_@" [WORDSSIC a] "@_" = <supplied evidence="parallel" reason="undefined">[WORDSSIC a]</>
	: "_@" [WORDSSIC a] "?" "@_" = <supplied cert="low" evidence="parallel" reason="undefined">[WORDSSIC a]</>
	>: "_@" [items a] "@_" = <supplied evidence="parallel" reason="undefined">[items a]</>
	>: "_@" [items a] "?" "@_" = <supplied cert="low" evidence="parallel" reason="undefined">[items a]</>
		
	//---lost_parallel---
	//  _[abc]_  - underlines
    : "_[" [WORDSSIC a] "]_" = <supplied evidence="parallel" reason="lost">[WORDSSIC a]</>
	>: "_[" [items a] "]_" = <supplied evidence="parallel" reason="lost">[items a]</>
//70
	//---number or fraction_no_symbol---
	//  #a#1/2# a = character representation and then the fraction it equals between next #'s
    : "<#=" [SYMBOLNUM s] [ENDNUM] = <num value=[SYMBOLNUM s]/>
	: "<#=" [SYMNUMMULTI m] "#>" = <num value=[SYMNUMMULTI m]/>
	: [BEGNUM] [WORDA o] "=#>" = <num>[WORDA o]</>
	: [BEGNUM] "frac" [ENDNUM] = <num type="fraction"/>
	
	//---fraction_number and whole_number symbol and multi_symbol---
	//  <#a#1/2#> a = symbol representation and then the number/fraction it equals after '='
    : [BEGNUM] [WORDA o] "=" [SYMBOLNUM s] [ENDNUM] = <num value=[SYMBOLNUM s]>[WORDA o]</>
	: [BEGNUM] [WORDA o] [morenum m] "=" [SYMBOLNUM s] [ENDNUM] = <num value=[SYMBOLNUM s]>[WORDA o] [morenum m]</>
	>: [BEGNUM] [items o] "=" [SYMBOLNUM s] [ENDNUM] = <num value=[SYMBOLNUM s]>[items o]</>
		
	//---subst---
	//  <:a|subst|b|:> 
	: [BEGOPT] [WORDVEST a] "|subst|" [WORDVEST b] "?" [ENDOPT] = <subst><add place="inline">[WORDVEST a]</><del cert="low" rend="corrected">[WORDVEST b]</></>
	>: [BEGOPT] [items a] "|subst|" [items b] "?" [ENDOPT] = <subst><add place="inline">[items a]</><del cert="low" rend="corrected">[items b]</></>
	: [BEGOPT] [WORDVEST a] "|subst|" [WORDVEST b] [ENDOPT] = <subst><add place="inline">[WORDVEST a]</><del rend="corrected">[WORDVEST b]</></>
//		>: [BEGOPT] [items a] "|subst|" [items b] [ENDOPT] = <subst><add place="inline">[items a]</><del rend="corrected">[items b]</></>
	>: [BEGOPT] [items a] "|subst|" [WORDVEST b] [ENDOPT] = <subst><add place="inline">[items a]</><del rend="corrected">[WORDVEST b]</></>
	>: [BEGOPT] [WORDVEST a] "|subst|" [items b] [ENDOPT] = <subst><add place="inline">[WORDVEST a]</><del rend="corrected">[items b]</></>
	>: [BEGOPT] [WORDVEST a] "?" "|subst|" [items b] [ENDOPT] = <subst><add cert="low" place="inline">[WORDVEST a]</><del rend="corrected">[items b]</></>
	>: [BEGOPT] [items a] "?" "|subst|" [items b] [ENDOPT] = <subst><add cert="low" place="inline">[items a]</><del rend="corrected">[items b]</></>
	>: [BEGOPT] [items a] "?" "|subst|" [items b] "?" [ENDOPT] = <subst><add cert="low" place="inline">[items a]</><del cert="low" rend="corrected">[items b]</></>
	>: [BEGOPT] [items a] "|subst|" [items b] [ENDOPT] = <subst><add place="inline">[items a]</><del rend="corrected">[items b]</></>
	>: [BEGOPT] "|subst|" [items b] [ENDOPT] = <subst><add place="inline"></><del rend="corrected">[items b]</></>
	
	//---app_lem---
	//  <:|abc|def|:> 
	: [BEGOPT] [WORD a] "|BL:" [WORDSLR c] "|" [WORD b] [QUESTION q] [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[WORD a]</><rdg>[WORD b][QUESTION q]</></>
//this set of app BL has 'lem resp=' attribute
//	>: [BEGOPT] [WORDOPT a] "|BL:" [WORDSLR c] "|" [WORDOPT b] [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[WORDOPT a]</><rdg>[WORDOPT b]</></>
//	>: [BEGOPT] [items a] "|BL:" [WORDSLR c] "|" [WORD b] [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[items a]</><rdg>[WORD b]</></>
//	>: [BEGOPT] [WORD a] "|BL:" [WORDSLR c] "|" [items b] [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[WORD a]</><rdg>[items b]</></>
	>: [BEGOPT] [items a] "|BL:" [WORDSLR c] "|" [items b] [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[items a]</><rdg>[items b]</></>
//line below added for empty tag rdg on BL
	>: [BEGOPT] [items a] "|BL:" [WORDSLR c] "|" [ENDOPT] = <app type="BL"><lem resp=[WORDSLR c]>[items a]</><rdg></></>
//this set of app Bl does not have 'lem resp=' attribute
	>: [BEGOPT] [items a] "|BL:|" [items b] [ENDOPT] = <app type="BL"><lem>[items a]</><rdg>[items b]</></>
	>: [BEGOPT] [items a] "|BL:|" [ENDOPT] = <app type="BL"><lem>[items a]</><rdg></></>
//	>: [BEGOPT] [WORDOPT a] "|BL:|" [WORDOPT b] [ENDOPT] = <app type="BL"><lem>[WORDOPT a]</><rdg>[WORDOPT b]</></>
//	>: [BEGOPT] [items a] "|BL:|" [WORD b] [ENDOPT] = <app type="BL"><lem>[items a]</><rdg>[WORD b]</></>
//	>: [BEGOPT] [WORD a] "|BL:|" [items b] [ENDOPT] = <app type="BL"><lem>[WORD a]</><rdg>[items b]</></>
	
//this set of app editorial has 'lem resp=' attribute
	: [BEGOPT] [WORD a] "|ed:" [WORDS e] "|" [WORD b] [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]>[WORD a]</><rdg>[WORD b]</></>
	>: [BEGOPT] [items a] "|ed:" [WORDS e] "|" [WORD b] [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]>[items a]</><rdg>[WORD b]</></>
	>: [BEGOPT] [WORD a] "|ed:" [WORDS e] "|" [items b] [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]>[WORD a]</><rdg>[items b]</></>
	>: [BEGOPT] [items a] "|ed:" [WORDS e] "|" [items b] [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]>[items a]</><rdg>[items b]</></>
//line below added for empty tag lem on editorial with resp
	>: [BEGOPT] "|ed:" [WORDS e] "|" [items b] [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]></><rdg>[items b]</></>
//line below added for empty tag lem on editorial without resp
	>: [BEGOPT] "|ed:" "|" [items b] [ENDOPT] = <app type="editorial"><lem/><rdg>[items b]</></>
//line below added for empty tag rdg on editorial with resp
	>: [BEGOPT] [items a] "|ed:" [WORDS e] "|" [ENDOPT] = <app type="editorial"><lem resp=[WORDS e]>[items a]</><rdg></></>
//line below added for the '(BL 1.24)' at the end of the 'lem resp=' attribute value - parens cannot be a valid value in WORD or WORDS
	>: [BEGOPT] [items a] "|ed:" [WORDSBL c] "|" [items b] [ENDOPT] = <app type="editorial"><lem resp=[WORDSBL c]>[items a]</><rdg>[items b]</></>
//this set of app editorial does not have 'lem resp=' attribute
	: [BEGOPT] [WORDSNONUM a] "|ed:|" [WORD b] [ENDOPT] = <app type="editorial"><lem>[WORDSNONUM a]</><rdg>[WORD b]</></>
	>: [BEGOPT] [items a] "|ed:|" [WORDVEST b] [ENDOPT] = <app type="editorial"><lem>[items a]</><rdg>[WORDVEST b]</></>
	>: [BEGOPT] [WORDSNONUM a] "|ed:|" [items b] [ENDOPT] = <app type="editorial"><lem>[WORDSNONUM a]</><rdg>[items b]</></>
	>: [BEGOPT] [items a] "|ed:|" [items b] [ENDOPT] = <app type="editorial"><lem>[items a]</><rdg>[items b]</></>
//line below added for empty tag rdg on editorial without resp
	>: [BEGOPT] [items a] "|ed:|" [ENDOPT] = <app type="editorial"><lem>[items a]</><rdg></></>
	: [BEGOPT] [WORD a] "|alt:|" [WORDVEST b] [ENDOPT] = <app type="alternative"><lem>[WORD a]</><rdg>[WORDVEST b]</></>
	>: [BEGOPT] [items a] "|alt:|" [WORDVEST b] [ENDOPT] = <app type="alternative"><lem>[items a]</><rdg>[WORDVEST b]</></>
	>: [BEGOPT] [WORD a] "|alt:|" [items b] [ENDOPT] = <app type="alternative"><lem>[WORD a]</><rdg>[items b]</></>
	>: [BEGOPT] [items a] "|alt:|" [items b] [ENDOPT] = <app type="alternative"><lem>[items a]</><rdg>[items b]</></>
//line below added for empty tag rdg on alternative
	>: [BEGOPT] [items a] "|alt:" "|" [ENDOPT] = <app type="alternative"><lem>[items a]</><rdg></></>
//line below added for empty tag lem on alternative
	>: [BEGOPT] "|alt:" "|" [items b] [ENDOPT] = <app type="alternative"><lem/><rdg>[items b]</></>
	
	//---glyph---
	//  '‚Äºa', '‚Äºa,b', '‚Äºfiller(a), ‚Äº@a , ‚Äºa b ' 
	: "*" [WORDS a] "*" = <g type=[WORDS a]></>
	: "*" [WORD a] "," [WORD b] "*" = <g type=[WORD a]>[WORD b]</>
	: "*filler(" [WORD a] ")" "*" = <g rend=[WORD a] type="filler"></>
	: "*@" [WORD a] "*" = <orig><g type=[WORD a]></></>
//	>: "‚Äº" [WORDS a] "‚Äº" = <g type=[WORDS a]></>
	
	//---hand_shift---
	//  $m# 
	: "$" [HANDSHIFT h] " " = <handShift new=[HANDSHIFT h]></>
	
	//---space_unknown---
	//  vac.? 
	: "vac.?" = <space extent="unknown" unit="character"></>
	
	//---note---
	//  /*abcdefg*/ 
	: "\/*" [WORDSF a] "*\/" = <note lang="en">[WORDSF a]</>
//	: "\/*" [WORDS a] [QUESTION b] "*\/" = <note lang="en">[WORDS a][QUESTION b]</>
//	: "\/*" [QUESTION b] "*\/" = <note lang="en">[QUESTION b]</>
	>: "\/*" [items b] "*\/" = <note lang="en">[items b]</>
	
	//---foreign_lang---
	//  ~veni vedi vici~la 
	: "~" [WORDSF a] "~" [WORD b] " " = <foreign lang=[WORD b]>[WORDSF a]</>
	>: "~" [items a] "~" [WORD b] " " = <foreign lang=[WORD b]>[items a]</>
	
	//---figure---
	//  fig.seal 
	: "#" [WORD a] " " = <figure><figDesc>[WORD a]</></>
	
	//---del_rend---
	//  not brackets - already defined in inside-brackets
//	: "„ÄöX" [WORDS a] "„Äõ" = <del rend="cross-strokes">[WORDS a]</>
	>: "„ÄöX" [items a] "„Äõ" = <del rend="cross-strokes">[items a]</>
// repeat of above with NL at end - if fix XML may not need these 2 lines
//	>: "„ÄöX" [WORDS a] "„Äõ" = <del rend="cross-strokes">[WORDS a] [NL]</>
//	>: "„ÄöX" [items a] "„Äõ" = <del rend="cross-strokes">[items a] [NL]</>
//	: "„Äö\/" [WORDS a] "„Äõ" = <del rend="slashes">[WORDS a]</>
	>: "„Äö\/" [items a] "„Äõ" = <del rend="slashes">[items a]</>
// repeat of above with NL at end - if fix XML may not need these 2 lines
//	>: "„Äö\/" [WORDS a] "„Äõ" = <del rend="slashes">[WORDS a] [NL]</>
//	>: "„Äö\/" [items a] "„Äõ" = <del rend="slashes">[items a] [NL]</>
//this one has to be last so the first case will be caught before get here because '-' is a valid WORDS character
//	>: "„Äö" [WORDS a] "„Äõ" = <del rend="erasure">[WORDS a]</>
	>: "„Äö" [items a] "„Äõ" = <del rend="erasure">[items a]</>
// repeat of above with NL at end - if fix XML may not need these 2 lines
//	>: "„Äö" [WORDS a] "„Äõ" = <del rend="erasure">[WORDS a] [NL]</>
//	>: "„Äö" [items a] "„Äõ" = <del rend="erasure">[items a] [NL]</>
	
	
	>: [flat f] = [flat f]


	
flat 
	//---test_expand low cert---
	// (?)
//	: [BEGEXP] "(" "  ?" ")" [ENDEXP] = <expan><ex cert="low"></></>
	: [BEGEXP] "()" [ENDEXP] = <expan><ex></></>
	:  [BEGEXP] "(" [SPO2 w] "?" ")" [ENDEXP]= <expan><ex cert="low">[SPO2 w]</></>
	
	//---test_expand low cert---
	// (abc?)
	>:  [BEGEXP] "(" [WORDS w] "?" ")" [ENDEXP]= <expan><ex cert="low">[WORDS w]</></>
//changed line below from words to word for a white space test 
	>: [BEGEXP] [WORD a] "(" [WORDS b] "?" ")" [ENDEXP] = <expan>[WORD a]<ex cert="low">[WORDS b]</></>
	>: [BEGEXP] [items a] "(" [WORDS b] "?" ")" [ENDEXP] = <expan>[items a]<ex cert="low">[WORDS b]</></>
//add 2 lines below 6/17 for p.kar.goodsp
	>: [BEGEXP] [items a] "(" [WORDS b] "?" ")" [items c] "(" [WORDS d] ")" [ENDEXP] = <expan>[items a]<ex cert="low">[WORDS b]</>[items c]<ex>[WORDS d]</></>
//change words to word for a below for white space test	
	>: [BEGEXP] [WORD a] "(" [WORDS b] ")" [WORDS c] "[" [WORDS d] "(" [WORDS e] ")" "]" [ENDEXP] = <expan>[WORD a]<ex>[WORDS b]</>[WORDS c]<supplied reason="lost">[WORDS d]<ex>[WORDS e]</></></>
//add 2 lines below 6/17 for p.oxy.17
	>: [BEGEXP] "(" "(" [WORD a] ")" [WORD c] "(" [WORD b] ")" ")" [ENDEXP] = <expan><ex>[WORD a]</>[WORD c]<ex>[WORD b]</></>
	>: [BEGEXP] "(" "(" [WORD a]  "?" ")" [WORD c] "(" [WORD b] ")" ")" [ENDEXP] = <expan><ex cert="low">[WORD a]</>[WORD c]<ex>[WORD b]</></>
	
	//---test_expansion---
	// a(b)
// comment the next line - causes 5 reversability and passing errors in EXPAN in BGU.1 - bgurakcov0414_v06
//	>: [WORD a] "(" [WORD b] __")" = <expan>[WORD a]<ex>[WORD b] __</></>
//jfox change words to word for a white space test
	>: [BEGEXP] [WORD a] "(" [WORDS b] ")" [ENDEXP] = <expan>[WORD a]<ex>[WORDS b]</></>
	
	//---test_symbol_expansion---
	// (abc)
//	: "(" [WORDSNUM a] ")" = <expan><ex>[WORDSNUM a]</></>
//: "(" [WORD a] __ [WORD b] ")" = <expan><ex>[WORD a] __ [WORD b]</></> - old definition of WORDSNUM i think
//	: "(" [WORD a] ")" = <expan><ex>[WORD a]</></> - commented out to remove vert ambig with wordsnum above
	: [BEGEXP] "(" "(" [WORD a] ")" [WORD c] "(" [WORD b] ")" ")" [ENDEXP] = <expan><ex>[WORD a]</>[WORD c]<ex>[WORD b]</></>
	>: [BEGEXP] [expandex e] [ENDEXP] = <expan>[expandex e]</>
	>: [BEGEXP] [WORD a] [expandex e] [ENDEXP] = <expan>[WORD a] [expandex e]</>
	>: [BEGEXP] [items d] "(" "(" [WORD a] ")" [WORD c] "(" [WORD b] ")" ")" [ENDEXP] = <expan>[items d]<ex>[WORD a]</>[WORD c]<ex>[WORD b]</></>
//	>: "(" [items a] ")" = <expan><ex>[items a]</></>

	//---test_vestige_lines---
	// vestig.#{n}lin
	: "vestig." [GAPEXTNUM v] "lin" = <gap desc="vestiges" extent=[GAPEXTNUM v] reason="illegible" unit="line"></>
	
	//---test_vestige_lines_ca---
	// vestig.ca.#{n}lin
	: "vestig.ca." [GAPEXTNUM v] "lin" = <gap reason="illegible" extent=[GAPEXTNUM v] unit="line" precision="circa" desc="vestiges"></>
	
	//---test_vestige_lines_unknown---
	// vestig.?lin
	: "vestig.?lin" = <gap extent="unknown" reason="illegible" unit="line"></>
	
	//---test_vestige_known_char---
	// vestig.!.#{n}
// changed per James conversation on 6/10 - desc="vestiges" and reason="illegible"
	: "vestig." [GAPEXTNUM v] "char" = <gap desc="vestiges" extent=[GAPEXTNUM v] reason="illegible" unit="character"></>
	
	//---test_vestige_characters---
	// vestig
	: "vestig" = <gap desc="vestiges" extent="unknown" reason="illegible" unit="character"></>
	
	//---test_nontran_characters---
	// nontran
	: "nontran" = <gap desc="non transcribed" extent="unknown" reason="ellipsis" unit="character"></>
	: "nontran." [NUM v] "-" [NUM w] = <gap desc="non transcribed" extent=[NUM v] extentmax=[NUM w] reason="ellipsis" unit="character"></>
	
	//---test_lost_lines---
	// lost.#{n}lin
	: "lost." [GAPEXTNUM v] "lin" = <gap extent=[GAPEXTNUM v] reason="lost" unit="line"></>
	>: "lost." [GAPEXTNUM v] "-" [GAPEXTNUM w] "lin" = <gap extent=[GAPEXTNUM v] extentmax=[GAPEXTNUM w] reason="lost" unit="line"></>
	
	//---test_lost_lines_unknown---
	// lost.#{n}lin
	: "lost." "?" "lin" = <gap extent="unknown" reason="lost" unit="line"></>
	
	//---test_quotation_marks---
	// " "
	>: "\"" [WORDS w] "\"" = <q>[WORDS w]</>
	>: "\"" [items i] "\"" = <q>[items i]</>
	
	//---test_omitted---
	//< >
	>: "<" [WORDS w] ">" = <supplied reason="omitted">[WORDS w]</>
	>: "<" [WORDS w] "?" ">" = <supplied cert="low" reason="omitted">[WORDS w]</>
	>: "<" [items i] ">" = <supplied reason="omitted">[items i]</>
	>: "<" [items w] "?" ">" = <supplied cert="low" reason="omitted">[items w]</>
	>: "<" ">" = <supplied reason="omitted"/>
	>: "<" "?" ">" = <supplied cert="low" reason="omitted"/>
	
	//---test_sic---
	//sic
	>: "{" [WORDSSIC w] "}" = <sic>[WORDSSIC w]</>	
	>: "{" [items w] "}" = <sic>[items w]</>
	
	//---test_seg---
	//seg
	>: [BEGSEG] [items i] [ENDSEG] = <seg cert="low">[items i]</>	
	
	//---expand with supplied reason lost---
	: [BEGEXP] [WORDOPT a] "[" [WORDOPT b] "(" [WORD c] ")" [WORDOPT d] "]" [WORDOPT e] [ENDEXP] = <expan>[WORDOPT a]<supplied reason="lost">[WORDOPT b]<ex>[WORD c]</>[WORDOPT d]</>[WORDOPT e]</>
	>: [BEGEXP] [items a] "[" [WORDOPT b] "(" [WORD c] ")" [WORDOPT d] "]" [WORDOPT e] [ENDEXP] = <expan>[items a]<supplied reason="lost">[WORDOPT b]<ex>[WORD c]</>[WORDOPT d]</>[WORDOPT e]</>
//jfox change words to word for a white space test
	>: [BEGEXP] [WORD a] "[" [WORDS b] "(" [WORDS c] ")" "]" [ENDEXP] = <expan>[WORD a]<supplied reason="lost">[WORDS b]<ex>[WORDS c]</></></>
	>: [BEGEXP] "[" "(" [WORDS c] ")" "]" [ENDEXP] = <expan><supplied reason="lost"><ex>[WORDS c]</></></>
	: [BEGEXP] [WORDOPT a] "[" [WORDOPT b] "(" [WORD c] "?" ")" [WORDOPT d] "]" [WORDOPT e] [ENDEXP] = <expan>[WORDOPT a]<supplied reason="lost">[WORDOPT b]<ex cert="low">[WORD c]</>[WORDOPT d]</>[WORDOPT e]</>
	
	: "[]" = <supplied reason="lost"/>
	: "[ ?]" = <supplied cert="low" reason="lost"/>
	
	//---multiple tests see inside_brackets production---
	// [ ], [[ ]], [ca.?] etc...
	>: "[" [inside_brackets i] "]" =  [inside_brackets i] 	
	
	//test below are after inside_brackets to keep from getting the definitions confused
	
	//---test_illegible_gap_unknown---
	// .?
	: ".?" = <gap extent="unknown" reason="illegible" unit="character"></>
	
	//---test_illegible_gap_unknown_ca---
	// ca.?
	: [CAUNKNOWN] = <gap reason="illegible" extent="unknown" unit="character" precision="circa"></>
	
	>: [ANYLETTER a] = [ANYLETTER a]
		
	
	
inside_brackets 
	
	//---test_lost_dot_gap---
	// .1, .2, .3 inside brackets
	: [DOT] [NUM n] = <gap extent=[NUM n] reason="lost" unit="character"></>
	// does not have [DOT] in front to be different from gap illegible which has the [DOT] up front
	: [GAPEXTNUM n] = <gap extent=[GAPEXTNUM n] reason="lost" unit="character"></>
	
	//---test_lost_dot_max---
	// .#{n}-#{n}
	: [DOT] [NUM v] "-" [NUM w] = <gap extent=[NUM v] extentmax=[NUM w] reason="lost" unit="character"></>
			
	//---test_lost_gap_unknown---
	// [.?] - diff from empty tag low cert because DOT and no space
	>: ".?" = <gap extent="unknown" reason="lost" unit="character"></>
	
	//---test_lost_gap_unknown_ca---
	// [ ca.?]  	
	>: [CAUNKNOWN] = <gap reason="lost" extent="unknown" unit="character" precision="circa"></>
	
	//---test_lost_space_unknown
	//[vac.?]
	:[ANYMULT w] "vac.?" = <supplied reason="lost">[ANYMULT w]<space extent="unknown" unit="character"/></>
	:"vac.?" [ANYMULT w] = <supplied reason="lost"><space extent="unknown" unit="character"/>[ANYMULT w]</>
	:"vac.?" = <supplied reason="lost"><space extent="unknown" unit="character"/></>
	:[ANYMULT w] "vac.?" [ANYMULT w] = <supplied reason="lost">[ANYMULT w]<space extent="unknown" unit="character"/>[ANYMULT w]</>
	
	
	//---test_lost_paragraphos
	//[----]
	:[ANYMULT w] "----" = <supplied reason="lost">[ANYMULT w]<milestone rend="paragraphos" unit="undefined"/></>
	:"----" = <supplied reason="lost"><milestone rend="paragraphos" unit="undefined"/></>
	:[ANYMULT w] "----" [ANYMULT x] = <supplied reason="lost">[ANYMULT w]<milestone rend="paragraphos" unit="undefined"/>[ANYMULT x]</>
	
	//---test_lost_words---
	// [ abc def ] lost words
	: [WORDSSIC w] = <supplied reason="lost">[WORDSSIC w]</>
	
	//---test_lost_uncertain---
	// [ abc? ] uncertain lost
	>: [WORDSSIC w] " ?" = <supplied cert="low" reason="lost">[WORDSSIC w]</>
	>: [items w] " ?" = <supplied cert="low" reason="lost">[items w]</>
	
	//---test_lost--- - placed at the end so all other possibilities of inside brackets are checked before looping through 'items' production
	// [ ] lost
	>: [items is] = <supplied reason="lost">[items is]</>
	>: [ANYLETTER w] [items is] = <supplied reason="lost">[ANYLETTER w] [items is]</>
	// the line above causes horizontal ambiguity if you put WORD or WORDS in it.  ANYLETTER is close to WORDS because it allows spaces but not comma - when added a
// comma to ANYLETTER it really messed things up so took it back out.  ANYLETTER keeps the horizontal ambiguity out of the grammar it gets is close to WORDS in
// solving grammar (within 1 on BGU.1 so going to leave that for now.  Not sure why WORD/WORDS causes ambiguity and ANYLETTER doesn't.
